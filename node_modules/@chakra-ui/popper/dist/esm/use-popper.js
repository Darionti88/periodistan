function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { filterUndefined } from "@chakra-ui/utils";
import { createPopper } from "@popperjs/core";
import { useCallback, useEffect, useMemo, useRef } from "react";
import * as popperModifiers from "./modifiers";
import { getEventListenerOptions } from "./utils";
var defaultProps = {
  placement: "bottom",
  strategy: "absolute",
  flip: true,
  gutter: 8,
  arrowPadding: 8,
  preventOverflow: true,
  eventListeners: true,
  modifiers: [],
  boundary: "clippingParents"
};
export function usePopper(props) {
  if (props === void 0) {
    props = {};
  }

  var opts = Object.assign({}, defaultProps, filterUndefined(props));
  var {
    modifiers = [],
    placement: placementProp,
    strategy,
    arrowPadding,
    eventListeners,
    offset,
    gutter,
    flip,
    boundary,
    preventOverflow,
    matchWidth
  } = opts;
  var reference = useRef(null);
  var popper = useRef(null);
  var instanceRef = useRef(null);
  var cleanup = useRef(() => {});
  var setupPopper = useCallback(() => {
    if (!reference.current || !popper.current) return;
    cleanup.current == null ? void 0 : cleanup.current();
    instanceRef.current = createPopper(reference.current, popper.current, {
      placement: placementProp,
      modifiers: modifiers.concat([popperModifiers.innerArrow, popperModifiers.positionArrow, popperModifiers.transformOrigin, _extends({}, popperModifiers.matchWidth, {
        enabled: !!matchWidth
      }), _extends({
        name: "eventListeners"
      }, getEventListenerOptions(eventListeners)), {
        name: "arrow",
        options: {
          padding: arrowPadding
        }
      }, {
        name: "offset",
        options: {
          offset: offset != null ? offset : [0, gutter]
        }
      }, {
        name: "flip",
        enabled: !!flip,
        options: {
          padding: 8
        }
      }, {
        name: "preventOverflow",
        enabled: !!preventOverflow,
        options: {
          boundary
        }
      }]),
      strategy
    }); // force update one-time to fix any positioning issues

    instanceRef.current.forceUpdate();
    cleanup.current = instanceRef.current.destroy;
  }, [placementProp, modifiers, matchWidth, eventListeners, arrowPadding, offset, gutter, flip, preventOverflow, boundary, strategy]);
  useEffect(() => {
    return () => {
      var _instanceRef$current;

      (_instanceRef$current = instanceRef.current) == null ? void 0 : _instanceRef$current.destroy();
      instanceRef.current = null;
    };
  }, []);
  return useMemo(() => {
    var _instanceRef$current2, _instanceRef$current3;

    return {
      update: (_instanceRef$current2 = instanceRef.current) == null ? void 0 : _instanceRef$current2.update,
      forceUpdate: (_instanceRef$current3 = instanceRef.current) == null ? void 0 : _instanceRef$current3.forceUpdate,
      referenceRef: node => {
        reference.current = node;
        setupPopper();
      },
      popperRef: node => {
        popper.current = node;
        setupPopper();
      }
    };
  }, [setupPopper]);
}
//# sourceMappingURL=use-popper.js.map